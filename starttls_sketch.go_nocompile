package main

// type ICMPPacket {
//     TargetIPv4 uint32
//     ReachedIPv4 uint32
//     Data []byte
// }

// func ParseICMP(buf []byte) ICMPPacket {
//     // Parse an ICMP packet
// }

func placeholder() {
    workers := 10 // number of threads, should be a flag (a flag from argv?)
        // ./smtp --workers 10
    icmp_socket := makeICMPSocket() // so there's only 1 ICMP socket open
    icmp_chan := make(chan ICMPPacket, workers*2) // and 1 ICMP chan for communicating
        // between the icmp_socket and all the other running threads
        // why workers*2? a full chan blocks. can hold 20 

    w := new(sync.WaitGroup) // basically a semaphore? +1 to wait. w.Done to decrement
        // After w reaches 0, the process can continue. So, shouldn't w.Add(1) be
        // inside the functions? no, cuz main() could end before one starts

    // This function creates a new go routine which creates a chan for 
    // communicating IP Addresses, and reads in IP Addresses
    input_chan := make(chan string, workers*2)
    w.Add(1)
    go func() {
        defer w.Done()
        for {
            // Read input line until end of file
            ip := readLine()
            input_chan <- ip // so this puts one IP into the chan and waits for
                // another goroutine to read it... then repeats? 
                // the program counter comes back here? or, which line?
        }
        close(input_chan)
    }()

    w.Add(1)
    go func() {
        defer w.Done()
        // Receive ICMP packets
        buf := make([]byte, 10000)
        for {
            err, n := icmp_socket.Recv(buf)
            if err == nil {
                packet := ParseICMP(buf[0:n])
                icmp_chan <- packet
                continue
            }
            if err == io.EOF {
                break
            }
            if err == io.Timeout {
                sleep(1)
                continue
            }
            panic(err.Error()) // does this end/kill the program? yes
                // do defer'd commands still run? probably not
        }
        close(icmp_chan)
    }() // () means run this now

    in_process := make(map[uint32]chan[ICMPPacket])
    m := new(sync.RWMutex())

    w.Add(1)
    go func() {
        // Dispatch packets to scanners
        defer w.Done()
        for packet := range icmp_chan {
            m.Lock() // lock accesses to in_process map
            defer m.Unlock()
            target := packet.TargetIPv4 // grab the target IP from the parsed ICMP 
            if c, ok := in_process[target]; ok { // if we have a worker for that target
                in_process[target] <- packet // tell the worker we got that packet
            }
        }
    }()


    worker_channels := make([]chan[ICMPPacket], workers)
    for idx := range worker_channels {
        worker_channels[idx] = make(chan[ICMPPacket], 1)
    }

    for worker := 0; worker < workers; worker++ {
        w.Add(1)
        c := worker_channels[worker]
        go func(c chan ICMPPacket) {
            defer w.Done()
            for ip := range input_chan {
//                for ttl := 4; ttl < MAX; ttl++ {
                    m.Lock() // this should be done in a function, and you should defer a call to function that removes the ip from the map
                    in_process[ip] = c
                    m.Unlock()

                    conn := net.Dial(ip)

                    // Speak everything up to starttls, go to next loop iteration over input_chan if there's an error
                    // Now STARTTLS
                    tcpResponseChan chan bool
                    hostTimeoutChan chan bool 
                    go func() {
                        res, err := ReadNormalStartTLSAnswerWithMaxTimeout(conn)
                        if err != nil {
                            tcpResponseChan <- res      
                        }
                        hostTimeoutChan <- true
                    }()
                    hostDone := false
                    ttlCount := 0
                    for ttl := 0; ttl < MAX_TTL && !hostDone; ttl++ {
                        SendWithTTL(conn, ttl)
                        hopDone := false
                        timeoutChan := GoStdlibFunctionToSendASignalInNSecond(2)
                        for !hopDone && !hostDone {
                            select {
                                case  icmpEcho <- c:
                                    // got an icmp packet
                                    hopDone = true
                                    // check for censorship in echo'd response
                                case tcpOk <- tcpResponseChan:
                                    hostDone = true
                                    ttlCount = ttl    
                                case _ <- timeoutChan:
                                    hopDone = true
                                    continue
                                case hostTimeout <- hostTimeoutChan:
                                    hostDone = true
                            }
                        }
                    }

                    // Make sure this is called on every error path inside the loop over input_chan
                    m.Lock()
                    delete(in_process, ip)
                    m.Unlock()


                    // - speak SMTP
                    // - send packet with modified ttl
                    // - recv with timeout
                    // - poll the right channel for this worker to see if an 
                    //     icmp packet arrives
                    // - see what happens first: icmp, actual data from recv, or
                    //     timeout on both
                    // - try the next ttl or mark as done, etc.
  //              }
            }
            close(c)
        }(c)
    }
    w.Wait()
}









// Sketch:

// func DoTTLExperiment() {
//     m.Lock()
//     in_process[target] = worker
//     m.Unlock()

//     defer func() {
//         m.Lock()
//         delete(in_process, target)
//         m.Unlock()
//     }()

//     // Rest of loop body
//     // Talk smtp
//     that select thing i'm still writing
//     all that stuff
//     output on success
//     return error if fails erarly
// }

// for ip := range inputChan {
//     DoTTLExperiment()
// }